// Automatically generated by Interoptopus.

#ifndef ffi_lib
#define ffi_lib

#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>




typedef struct simpleservice simpleservice;

/// A basic vector 3 in our FFI layer using integers.
typedef struct vec3 vec3;

typedef struct vec4 vec4;

typedef enum ffierror
    {
    FFIERROR_OK = 0,
    FFIERROR_NULL = 100,
    FFIERROR_PANIC = 200,
    FFIERROR_FAIL = 300,
    } ffierror;

/// A simple type in our FFI layer.
typedef struct vec2
    {
    float x;
    float y;
    } vec2;

/// The basic struct we will call methods in our FFI layer.
typedef struct vec3
    {
    int x;
    int y;
    int z;
    } vec3;


/// Function using the type.
vec2 my_function(vec2 input);

void hello(const char* name);

double benchmark_rust();

double benchmark_rust_async();

/// Destroys the given instance.
///
/// # Safety
///
/// The passed parameter MUST have been created with the corresponding init function;
/// passing any other value results in undefined behavior.
ffierror simple_service_destroy(simpleservice** context);

ffierror simple_service_new_with(simpleservice** context, unsigned int some_value);

/// Destroys the given instance.
///
/// # Safety
///
/// The passed parameter MUST have been created with the corresponding init function;
/// passing any other value results in undefined behavior.
ffierror vec4_destroy(vec4** context);

ffierror vec4_new(vec4** context, float x, float y, float z, float w);

float vec4_dot(const vec4* context, const vec4* other);

float vec4_get_x(const vec4* context);

float vec4_get_y(const vec4* context);

float vec4_get_z(const vec4* context);

float vec4_get_w(const vec4* context);

void vec4_set_x(vec4* context, float value);

void vec4_set_y(vec4* context, float value);

void vec4_set_z(vec4* context, float value);

void vec4_set_w(vec4* context, float value);

void init_logger();

/// Destroys the given instance.
///
/// # Safety
///
/// The passed parameter MUST have been created with the corresponding init function;
/// passing any other value results in undefined behavior.
ffierror vec3_destroy(vec3** context);

ffierror vec3_new(vec3** context, int x, int y, int z);

int vec3_add(vec3* context, int x, int y, int z);

int vec3_add_reverse_args(vec3* context, int x, int y, int z);

int vec3_dot(const vec3* context, const vec3* other);

vec3 vec3_cross(const vec3* context, const vec3* other);

vec3 vec3_normalize(const vec3* context);

int vec3_get_x(const vec3* context);

int vec3_get_y(const vec3* context);

int vec3_get_z(const vec3* context);

#ifdef __cplusplus
class SimpleService
{
    private:
        simpleservice* _context;
    public:

        SimpleService() : _context(nullptr) {}
        ~SimpleService() { Dispose(); }

        static SimpleService NewWith(unsigned int some_value)
        {
            SimpleService self;
            ffierror rval = simple_service_new_with(&self._context, some_value);
            if (rval != FFIERROR_OK)
            {
                throw rval;
            }
            return self;
        }

        void Dispose()
        {
            ffierror rval = simple_service_destroy(&_context);
            if (rval != FFIERROR_OK)
            {
                throw rval;
            }
        }

        simpleservice* Context() const { return _context; }
    private:
        explicit SimpleService(simpleservice* context) : _context(context) {}
    public:
        static SimpleService FromContext(simpleservice* context) { return SimpleService(context); }
};
#endif /* __cplusplus */

#ifdef __cplusplus
class Vec4
{
    private:
        vec4* _context;
    public:

        Vec4() : _context(nullptr) {}
        ~Vec4() { Dispose(); }

        static Vec4 New(float x, float y, float z, float w)
        {
            Vec4 self;
            ffierror rval = vec4_new(&self._context, x, y, z, w);
            if (rval != FFIERROR_OK)
            {
                throw rval;
            }
            return self;
        }

        void Dispose()
        {
            ffierror rval = vec4_destroy(&_context);
            if (rval != FFIERROR_OK)
            {
                throw rval;
            }
        }

        float Dot(const vec4* other)
        {
            return vec4_dot(_context, other);
        }

        float GetX()
        {
            return vec4_get_x(_context);
        }

        float GetY()
        {
            return vec4_get_y(_context);
        }

        float GetZ()
        {
            return vec4_get_z(_context);
        }

        float GetW()
        {
            return vec4_get_w(_context);
        }

        void SetX(float value)
        {
            vec4_set_x(_context, value);
        }

        void SetY(float value)
        {
            vec4_set_y(_context, value);
        }

        void SetZ(float value)
        {
            vec4_set_z(_context, value);
        }

        void SetW(float value)
        {
            vec4_set_w(_context, value);
        }

        vec4* Context() const { return _context; }
    private:
        explicit Vec4(vec4* context) : _context(context) {}
    public:
        static Vec4 FromContext(vec4* context) { return Vec4(context); }
};
#endif /* __cplusplus */

/// A basic vector 3 in our FFI layer using integers.
#ifdef __cplusplus
class Vec3
{
    private:
        vec3* _context;
    public:

        Vec3() : _context(nullptr) {}
        ~Vec3() { Dispose(); }

        static Vec3 New(int x, int y, int z)
        {
            Vec3 self;
            ffierror rval = vec3_new(&self._context, x, y, z);
            if (rval != FFIERROR_OK)
            {
                throw rval;
            }
            return self;
        }

        void Dispose()
        {
            ffierror rval = vec3_destroy(&_context);
            if (rval != FFIERROR_OK)
            {
                throw rval;
            }
        }

        int Add(int x, int y, int z)
        {
            return vec3_add(_context, x, y, z);
        }

        int AddReverseArgs(int x, int y, int z)
        {
            return vec3_add_reverse_args(_context, x, y, z);
        }

        int Dot(const vec3* other)
        {
            return vec3_dot(_context, other);
        }

        Vec3 Cross(const vec3* other)
        {
            vec3 result = vec3_cross(_context, other);
            return Vec3::FromContext(&result);
        }

        Vec3 Normalize()
        {
            vec3 result = vec3_normalize(_context);
            return Vec3::FromContext(&result);
        }

        int GetX() const {
        return _context->x;
        }

        int GetY() const {
            return _context->y;
        }

        int GetZ() const {
            return _context->z;
        }

        void SetX(int value) {
            _context->x = value;
        }

        vec3* Context() const { return _context; }
    private:
        explicit Vec3(vec3* context) : _context(context) {}
    public:
        static Vec3 FromContext(vec3* context) { return Vec3(context); }
};
#endif /* __cplusplus */


#ifdef __cplusplus
}
#endif

#endif /* ffi_lib */
